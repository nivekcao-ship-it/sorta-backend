"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChunkingStrategy = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
/**
 * Knowledge base can split your source data into chunks. A chunk refers to an
 * excerpt from a data source that is returned when the knowledge base that it
 * belongs to is queried. You have the following options for chunking your
 * data. If you opt for NONE, then you may want to pre-process your files by
 * splitting them up such that each file corresponds to a chunk.
 */
var ChunkingStrategyType;
(function (ChunkingStrategyType) {
    /**
     * Amazon Bedrock splits your source data into chunks of the approximate size
     * that you set in the `fixedSizeChunkingConfiguration`.
     */
    ChunkingStrategyType["FIXED_SIZE"] = "FIXED_SIZE";
    /**
     * Splits documents into layers of chunks where the first layer contains large
     * chunks, and the second layer contains smaller chunks derived from the first
     * layer. You set the maximum parent chunk token size and the maximum child
     * chunk token size. You also set the absolute number of overlap tokens between
     * consecutive parent chunks and consecutive child chunks.
     */
    ChunkingStrategyType["HIERARCHICAL"] = "HIERARCHICAL";
    /**
     * Splits documents into semantically similar text chunks or groups of
     * sentences by using a foundation model. Note that there are additional
     * costs to using semantic chunking due to its use of a foundation model.
     */
    ChunkingStrategyType["SEMANTIC"] = "SEMANTIC";
    /**
     * Amazon Bedrock treats each file as one chunk. If you choose this option,
     * you may want to pre-process your documents by splitting them into separate
     * files.
     */
    ChunkingStrategyType["NONE"] = "NONE";
})(ChunkingStrategyType || (ChunkingStrategyType = {}));
class ChunkingStrategy {
    // ------------------------------------------------------
    // Static Methods for Customization
    // ------------------------------------------------------
    /** Method for customizing a fixed sized chunking strategy. */
    static fixedSize(props) {
        return {
            configuration: {
                chunkingStrategy: ChunkingStrategyType.FIXED_SIZE,
                fixedSizeChunkingConfiguration: props,
            },
        };
    }
    /**
     * Method for customizing a hierarchical chunking strategy.
     * For custom chunking, the maximum token chunk size depends on the model.
     * - Amazon Titan Text Embeddings: 8192
     * - Cohere Embed models: 512
    */
    static hierarchical(props) {
        return {
            configuration: {
                chunkingStrategy: ChunkingStrategyType.HIERARCHICAL,
                hierarchicalChunkingConfiguration: {
                    overlapTokens: props.overlapTokens,
                    levelConfigurations: [
                        { maxTokens: props.maxParentTokenSize },
                        { maxTokens: props.maxChildTokenSize },
                    ],
                },
            },
        };
    }
    /**
     * Method for customizing a semantic chunking strategy.
     * For custom chunking, the maximum token chunk size depends on the model.
     * - Amazon Titan Text Embeddings: 8192
     * - Cohere Embed models: 512
    */
    static semantic(props) {
        return {
            configuration: {
                chunkingStrategy: ChunkingStrategyType.SEMANTIC,
                semanticChunkingConfiguration: props,
            },
        };
    }
    /** Method for defining a no chunking strategy. */
    static noChunking() {
        return {
            configuration: {
                chunkingStrategy: ChunkingStrategyType.NONE,
            },
        };
    }
    constructor() { }
}
exports.ChunkingStrategy = ChunkingStrategy;
_a = JSII_RTTI_SYMBOL_1;
ChunkingStrategy[_a] = { fqn: "@cdklabs/generative-ai-cdk-constructs.bedrock.ChunkingStrategy", version: "0.1.309" };
// ------------------------------------------------------
// Static Constants for Easy Customization
// ------------------------------------------------------
/**
 * Fixed Sized Chunking with the default chunk size of 300 tokens and 20% overlap.
 */
ChunkingStrategy.DEFAULT = ChunkingStrategy.fixedSize({ maxTokens: 300, overlapPercentage: 20 });
/**
 * Fixed Sized Chunking with the default chunk size of 300 tokens and 20% overlap.
 * You can adjust these values based on your specific requirements using the
 * `ChunkingStrategy.fixedSize(params)` method.
 */
ChunkingStrategy.FIXED_SIZE = ChunkingStrategy.fixedSize({ maxTokens: 300, overlapPercentage: 20 });
/**
 * Hierarchical Chunking with the default for Cohere Models.
 * - Overlap tokens: 30
 * - Max parent token size: 500
 * - Max child token size: 100
 */
ChunkingStrategy.HIERARCHICAL_COHERE = ChunkingStrategy.hierarchical({ overlapTokens: 60, maxParentTokenSize: 500, maxChildTokenSize: 300 });
/**
 * Hierarchical Chunking with the default for Titan Models.
 * - Overlap tokens: 60
 * - Max parent token size: 1500
 * - Max child token size: 300
 */
ChunkingStrategy.HIERARCHICAL_TITAN = ChunkingStrategy.hierarchical({ overlapTokens: 60, maxParentTokenSize: 1500, maxChildTokenSize: 300 });
/**
 * Semantic Chunking with the default of bufferSize: 0,
 * breakpointPercentileThreshold: 95, and maxTokens: 300.
 * You can adjust these values based on your specific requirements using the
 * `ChunkingStrategy.semantic(params)` method.
 */
ChunkingStrategy.SEMANTIC = ChunkingStrategy.semantic({ bufferSize: 0, breakpointPercentileThreshold: 95, maxTokens: 300 });
/**
 * Amazon Bedrock treats each file as one chunk. Suitable for documents that
 * are already pre-processed or text split.
 */
ChunkingStrategy.NONE = ChunkingStrategy.noChunking();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY2RrLWxpYi9iZWRyb2NrL2RhdGEtc291cmNlcy9jaHVua2luZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQWVBOzs7Ozs7R0FNRztBQUNILElBQUssb0JBMEJKO0FBMUJELFdBQUssb0JBQW9CO0lBQ3ZCOzs7T0FHRztJQUNILGlEQUF5QixDQUFBO0lBQ3pCOzs7Ozs7T0FNRztJQUNILHFEQUE2QixDQUFBO0lBQzdCOzs7O09BSUc7SUFDSCw2Q0FBcUIsQ0FBQTtJQUNyQjs7OztPQUlHO0lBQ0gscUNBQWEsQ0FBQTtBQUNmLENBQUMsRUExQkksb0JBQW9CLEtBQXBCLG9CQUFvQixRQTBCeEI7QUFtQkQsTUFBc0IsZ0JBQWdCO0lBb0RwQyx5REFBeUQ7SUFDekQsbUNBQW1DO0lBQ25DLHlEQUF5RDtJQUN6RCw4REFBOEQ7SUFDdkQsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUEyRDtRQUNqRixPQUFPO1lBQ0wsYUFBYSxFQUFFO2dCQUNiLGdCQUFnQixFQUFFLG9CQUFvQixDQUFDLFVBQVU7Z0JBQ2pELDhCQUE4QixFQUFFLEtBQUs7YUFDdEM7U0FDRixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7OztNQUtFO0lBQ0ssTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFnQztRQUN6RCxPQUFPO1lBQ0wsYUFBYSxFQUFFO2dCQUNiLGdCQUFnQixFQUFFLG9CQUFvQixDQUFDLFlBQVk7Z0JBQ25ELGlDQUFpQyxFQUFFO29CQUNqQyxhQUFhLEVBQUUsS0FBSyxDQUFDLGFBQWE7b0JBQ2xDLG1CQUFtQixFQUFFO3dCQUNuQixFQUFFLFNBQVMsRUFBRSxLQUFLLENBQUMsa0JBQWtCLEVBQUU7d0JBQ3ZDLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxpQkFBaUIsRUFBRTtxQkFDdkM7aUJBQ0Y7YUFDRjtTQUNGLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7O01BS0U7SUFDSyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQTBEO1FBQy9FLE9BQU87WUFDTCxhQUFhLEVBQUU7Z0JBQ2IsZ0JBQWdCLEVBQUUsb0JBQW9CLENBQUMsUUFBUTtnQkFDL0MsNkJBQTZCLEVBQUUsS0FBSzthQUNyQztTQUNGLENBQUM7SUFDSixDQUFDO0lBRUQsa0RBQWtEO0lBQzFDLE1BQU0sQ0FBQyxVQUFVO1FBQ3ZCLE9BQU87WUFDTCxhQUFhLEVBQUU7Z0JBQ2IsZ0JBQWdCLEVBQUUsb0JBQW9CLENBQUMsSUFBSTthQUM1QztTQUNGLENBQUM7SUFDSixDQUFDO0lBT0QsZ0JBQXdCLENBQUM7O0FBbkgzQiw0Q0FvSEM7OztBQW5IQyx5REFBeUQ7QUFDekQsMENBQTBDO0FBQzFDLHlEQUF5RDtBQUN6RDs7R0FFRztBQUNvQix3QkFBTyxHQUFHLGdCQUFnQixDQUFDLFNBQVMsQ0FDekQsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLGlCQUFpQixFQUFFLEVBQUUsRUFBRSxDQUMxQyxDQUFDO0FBQ0Y7Ozs7R0FJRztBQUNvQiwyQkFBVSxHQUFHLGdCQUFnQixDQUFDLFNBQVMsQ0FDNUQsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLGlCQUFpQixFQUFFLEVBQUUsRUFBRSxDQUMxQyxDQUFDO0FBQ0Y7Ozs7O0dBS0c7QUFDb0Isb0NBQW1CLEdBQUcsZ0JBQWdCLENBQUMsWUFBWSxDQUN4RSxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsR0FBRyxFQUFFLGlCQUFpQixFQUFFLEdBQUcsRUFBRSxDQUN2RSxDQUFDO0FBRUY7Ozs7O0dBS0c7QUFDb0IsbUNBQWtCLEdBQUcsZ0JBQWdCLENBQUMsWUFBWSxDQUN2RSxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsSUFBSSxFQUFFLGlCQUFpQixFQUFFLEdBQUcsRUFBRSxDQUN4RSxDQUFDO0FBQ0Y7Ozs7O0dBS0c7QUFDb0IseUJBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxRQUFRLENBQ3pELEVBQUUsVUFBVSxFQUFFLENBQUMsRUFBRSw2QkFBNkIsRUFBRSxFQUFFLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxDQUNyRSxDQUFDO0FBQ0Y7OztHQUdHO0FBQ29CLHFCQUFJLEdBQUcsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKS4gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogIHdpdGggdGhlIExpY2Vuc2UuIEEgY29weSBvZiB0aGUgTGljZW5zZSBpcyBsb2NhdGVkIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgb3IgaW4gdGhlICdsaWNlbnNlJyBmaWxlIGFjY29tcGFueWluZyB0aGlzIGZpbGUuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVNcbiAqICBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xuICogIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDZm5EYXRhU291cmNlIH0gZnJvbSAnYXdzLWNkay1saWIvYXdzLWJlZHJvY2snO1xuXG4vKipcbiAqIEtub3dsZWRnZSBiYXNlIGNhbiBzcGxpdCB5b3VyIHNvdXJjZSBkYXRhIGludG8gY2h1bmtzLiBBIGNodW5rIHJlZmVycyB0byBhblxuICogZXhjZXJwdCBmcm9tIGEgZGF0YSBzb3VyY2UgdGhhdCBpcyByZXR1cm5lZCB3aGVuIHRoZSBrbm93bGVkZ2UgYmFzZSB0aGF0IGl0XG4gKiBiZWxvbmdzIHRvIGlzIHF1ZXJpZWQuIFlvdSBoYXZlIHRoZSBmb2xsb3dpbmcgb3B0aW9ucyBmb3IgY2h1bmtpbmcgeW91clxuICogZGF0YS4gSWYgeW91IG9wdCBmb3IgTk9ORSwgdGhlbiB5b3UgbWF5IHdhbnQgdG8gcHJlLXByb2Nlc3MgeW91ciBmaWxlcyBieVxuICogc3BsaXR0aW5nIHRoZW0gdXAgc3VjaCB0aGF0IGVhY2ggZmlsZSBjb3JyZXNwb25kcyB0byBhIGNodW5rLlxuICovXG5lbnVtIENodW5raW5nU3RyYXRlZ3lUeXBlIHtcbiAgLyoqXG4gICAqIEFtYXpvbiBCZWRyb2NrIHNwbGl0cyB5b3VyIHNvdXJjZSBkYXRhIGludG8gY2h1bmtzIG9mIHRoZSBhcHByb3hpbWF0ZSBzaXplXG4gICAqIHRoYXQgeW91IHNldCBpbiB0aGUgYGZpeGVkU2l6ZUNodW5raW5nQ29uZmlndXJhdGlvbmAuXG4gICAqL1xuICBGSVhFRF9TSVpFID0gJ0ZJWEVEX1NJWkUnLFxuICAvKipcbiAgICogU3BsaXRzIGRvY3VtZW50cyBpbnRvIGxheWVycyBvZiBjaHVua3Mgd2hlcmUgdGhlIGZpcnN0IGxheWVyIGNvbnRhaW5zIGxhcmdlXG4gICAqIGNodW5rcywgYW5kIHRoZSBzZWNvbmQgbGF5ZXIgY29udGFpbnMgc21hbGxlciBjaHVua3MgZGVyaXZlZCBmcm9tIHRoZSBmaXJzdFxuICAgKiBsYXllci4gWW91IHNldCB0aGUgbWF4aW11bSBwYXJlbnQgY2h1bmsgdG9rZW4gc2l6ZSBhbmQgdGhlIG1heGltdW0gY2hpbGRcbiAgICogY2h1bmsgdG9rZW4gc2l6ZS4gWW91IGFsc28gc2V0IHRoZSBhYnNvbHV0ZSBudW1iZXIgb2Ygb3ZlcmxhcCB0b2tlbnMgYmV0d2VlblxuICAgKiBjb25zZWN1dGl2ZSBwYXJlbnQgY2h1bmtzIGFuZCBjb25zZWN1dGl2ZSBjaGlsZCBjaHVua3MuXG4gICAqL1xuICBISUVSQVJDSElDQUwgPSAnSElFUkFSQ0hJQ0FMJyxcbiAgLyoqXG4gICAqIFNwbGl0cyBkb2N1bWVudHMgaW50byBzZW1hbnRpY2FsbHkgc2ltaWxhciB0ZXh0IGNodW5rcyBvciBncm91cHMgb2ZcbiAgICogc2VudGVuY2VzIGJ5IHVzaW5nIGEgZm91bmRhdGlvbiBtb2RlbC4gTm90ZSB0aGF0IHRoZXJlIGFyZSBhZGRpdGlvbmFsXG4gICAqIGNvc3RzIHRvIHVzaW5nIHNlbWFudGljIGNodW5raW5nIGR1ZSB0byBpdHMgdXNlIG9mIGEgZm91bmRhdGlvbiBtb2RlbC5cbiAgICovXG4gIFNFTUFOVElDID0gJ1NFTUFOVElDJyxcbiAgLyoqXG4gICAqIEFtYXpvbiBCZWRyb2NrIHRyZWF0cyBlYWNoIGZpbGUgYXMgb25lIGNodW5rLiBJZiB5b3UgY2hvb3NlIHRoaXMgb3B0aW9uLFxuICAgKiB5b3UgbWF5IHdhbnQgdG8gcHJlLXByb2Nlc3MgeW91ciBkb2N1bWVudHMgYnkgc3BsaXR0aW5nIHRoZW0gaW50byBzZXBhcmF0ZVxuICAgKiBmaWxlcy5cbiAgICovXG4gIE5PTkUgPSAnTk9ORScsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGllcmFyY2hpY2FsQ2h1bmtpbmdQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgb3ZlcmxhcCB0b2tlbnMgYmV0d2VlbiBhZGphY2VudCBjaHVua3MuXG4gICAqL1xuICByZWFkb25seSBvdmVybGFwVG9rZW5zOiBudW1iZXI7XG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiB0b2tlbnMgdGhhdCBhIHBhcmVudCBjaHVuayBjYW4gY29udGFpbi5cbiAgICogS2VlcCBpbiBtaW5kIHRoZSBtYXhpbXVtIGNodW5rIHNpemUgZGVwZW5kcyBvbiB0aGUgZW1iZWRkaW5nIG1vZGVsIGNob3Nlbi5cbiAgICovXG4gIHJlYWRvbmx5IG1heFBhcmVudFRva2VuU2l6ZTogbnVtYmVyO1xuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2YgdG9rZW5zIHRoYXQgYSBjaGlsZCBjaHVuayBjYW4gY29udGFpbi5cbiAgICogS2VlcCBpbiBtaW5kIHRoZSBtYXhpbXVtIGNodW5rIHNpemUgZGVwZW5kcyBvbiB0aGUgZW1iZWRkaW5nIG1vZGVsIGNob3Nlbi5cbiAgICovXG4gIHJlYWRvbmx5IG1heENoaWxkVG9rZW5TaXplOiBudW1iZXI7XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDaHVua2luZ1N0cmF0ZWd5IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFN0YXRpYyBDb25zdGFudHMgZm9yIEVhc3kgQ3VzdG9taXphdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEZpeGVkIFNpemVkIENodW5raW5nIHdpdGggdGhlIGRlZmF1bHQgY2h1bmsgc2l6ZSBvZiAzMDAgdG9rZW5zIGFuZCAyMCUgb3ZlcmxhcC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVCA9IENodW5raW5nU3RyYXRlZ3kuZml4ZWRTaXplKFxuICAgIHsgbWF4VG9rZW5zOiAzMDAsIG92ZXJsYXBQZXJjZW50YWdlOiAyMCB9LFxuICApO1xuICAvKipcbiAgICogRml4ZWQgU2l6ZWQgQ2h1bmtpbmcgd2l0aCB0aGUgZGVmYXVsdCBjaHVuayBzaXplIG9mIDMwMCB0b2tlbnMgYW5kIDIwJSBvdmVybGFwLlxuICAgKiBZb3UgY2FuIGFkanVzdCB0aGVzZSB2YWx1ZXMgYmFzZWQgb24geW91ciBzcGVjaWZpYyByZXF1aXJlbWVudHMgdXNpbmcgdGhlXG4gICAqIGBDaHVua2luZ1N0cmF0ZWd5LmZpeGVkU2l6ZShwYXJhbXMpYCBtZXRob2QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEZJWEVEX1NJWkUgPSBDaHVua2luZ1N0cmF0ZWd5LmZpeGVkU2l6ZShcbiAgICB7IG1heFRva2VuczogMzAwLCBvdmVybGFwUGVyY2VudGFnZTogMjAgfSxcbiAgKTtcbiAgLyoqXG4gICAqIEhpZXJhcmNoaWNhbCBDaHVua2luZyB3aXRoIHRoZSBkZWZhdWx0IGZvciBDb2hlcmUgTW9kZWxzLlxuICAgKiAtIE92ZXJsYXAgdG9rZW5zOiAzMFxuICAgKiAtIE1heCBwYXJlbnQgdG9rZW4gc2l6ZTogNTAwXG4gICAqIC0gTWF4IGNoaWxkIHRva2VuIHNpemU6IDEwMFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBISUVSQVJDSElDQUxfQ09IRVJFID0gQ2h1bmtpbmdTdHJhdGVneS5oaWVyYXJjaGljYWwoXG4gICAgeyBvdmVybGFwVG9rZW5zOiA2MCwgbWF4UGFyZW50VG9rZW5TaXplOiA1MDAsIG1heENoaWxkVG9rZW5TaXplOiAzMDAgfSxcbiAgKTtcblxuICAvKipcbiAgICogSGllcmFyY2hpY2FsIENodW5raW5nIHdpdGggdGhlIGRlZmF1bHQgZm9yIFRpdGFuIE1vZGVscy5cbiAgICogLSBPdmVybGFwIHRva2VuczogNjBcbiAgICogLSBNYXggcGFyZW50IHRva2VuIHNpemU6IDE1MDBcbiAgICogLSBNYXggY2hpbGQgdG9rZW4gc2l6ZTogMzAwXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEhJRVJBUkNISUNBTF9USVRBTiA9IENodW5raW5nU3RyYXRlZ3kuaGllcmFyY2hpY2FsKFxuICAgIHsgb3ZlcmxhcFRva2VuczogNjAsIG1heFBhcmVudFRva2VuU2l6ZTogMTUwMCwgbWF4Q2hpbGRUb2tlblNpemU6IDMwMCB9LFxuICApO1xuICAvKipcbiAgICogU2VtYW50aWMgQ2h1bmtpbmcgd2l0aCB0aGUgZGVmYXVsdCBvZiBidWZmZXJTaXplOiAwLFxuICAgKiBicmVha3BvaW50UGVyY2VudGlsZVRocmVzaG9sZDogOTUsIGFuZCBtYXhUb2tlbnM6IDMwMC5cbiAgICogWW91IGNhbiBhZGp1c3QgdGhlc2UgdmFsdWVzIGJhc2VkIG9uIHlvdXIgc3BlY2lmaWMgcmVxdWlyZW1lbnRzIHVzaW5nIHRoZVxuICAgKiBgQ2h1bmtpbmdTdHJhdGVneS5zZW1hbnRpYyhwYXJhbXMpYCBtZXRob2QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFNFTUFOVElDID0gQ2h1bmtpbmdTdHJhdGVneS5zZW1hbnRpYyhcbiAgICB7IGJ1ZmZlclNpemU6IDAsIGJyZWFrcG9pbnRQZXJjZW50aWxlVGhyZXNob2xkOiA5NSwgbWF4VG9rZW5zOiAzMDAgfSxcbiAgKTtcbiAgLyoqXG4gICAqIEFtYXpvbiBCZWRyb2NrIHRyZWF0cyBlYWNoIGZpbGUgYXMgb25lIGNodW5rLiBTdWl0YWJsZSBmb3IgZG9jdW1lbnRzIHRoYXRcbiAgICogYXJlIGFscmVhZHkgcHJlLXByb2Nlc3NlZCBvciB0ZXh0IHNwbGl0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBOT05FID0gQ2h1bmtpbmdTdHJhdGVneS5ub0NodW5raW5nKCk7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFN0YXRpYyBNZXRob2RzIGZvciBDdXN0b21pemF0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKiogTWV0aG9kIGZvciBjdXN0b21pemluZyBhIGZpeGVkIHNpemVkIGNodW5raW5nIHN0cmF0ZWd5LiAqL1xuICBwdWJsaWMgc3RhdGljIGZpeGVkU2l6ZShwcm9wczogQ2ZuRGF0YVNvdXJjZS5GaXhlZFNpemVDaHVua2luZ0NvbmZpZ3VyYXRpb25Qcm9wZXJ0eSk6IENodW5raW5nU3RyYXRlZ3kge1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgIGNodW5raW5nU3RyYXRlZ3k6IENodW5raW5nU3RyYXRlZ3lUeXBlLkZJWEVEX1NJWkUsXG4gICAgICAgIGZpeGVkU2l6ZUNodW5raW5nQ29uZmlndXJhdGlvbjogcHJvcHMsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGZvciBjdXN0b21pemluZyBhIGhpZXJhcmNoaWNhbCBjaHVua2luZyBzdHJhdGVneS5cbiAgICogRm9yIGN1c3RvbSBjaHVua2luZywgdGhlIG1heGltdW0gdG9rZW4gY2h1bmsgc2l6ZSBkZXBlbmRzIG9uIHRoZSBtb2RlbC5cbiAgICogLSBBbWF6b24gVGl0YW4gVGV4dCBFbWJlZGRpbmdzOiA4MTkyXG4gICAqIC0gQ29oZXJlIEVtYmVkIG1vZGVsczogNTEyXG4gICovXG4gIHB1YmxpYyBzdGF0aWMgaGllcmFyY2hpY2FsKHByb3BzOiBIaWVyYXJjaGljYWxDaHVua2luZ1Byb3BzKTogQ2h1bmtpbmdTdHJhdGVneSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgY2h1bmtpbmdTdHJhdGVneTogQ2h1bmtpbmdTdHJhdGVneVR5cGUuSElFUkFSQ0hJQ0FMLFxuICAgICAgICBoaWVyYXJjaGljYWxDaHVua2luZ0NvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICBvdmVybGFwVG9rZW5zOiBwcm9wcy5vdmVybGFwVG9rZW5zLFxuICAgICAgICAgIGxldmVsQ29uZmlndXJhdGlvbnM6IFtcbiAgICAgICAgICAgIHsgbWF4VG9rZW5zOiBwcm9wcy5tYXhQYXJlbnRUb2tlblNpemUgfSxcbiAgICAgICAgICAgIHsgbWF4VG9rZW5zOiBwcm9wcy5tYXhDaGlsZFRva2VuU2l6ZSB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGZvciBjdXN0b21pemluZyBhIHNlbWFudGljIGNodW5raW5nIHN0cmF0ZWd5LlxuICAgKiBGb3IgY3VzdG9tIGNodW5raW5nLCB0aGUgbWF4aW11bSB0b2tlbiBjaHVuayBzaXplIGRlcGVuZHMgb24gdGhlIG1vZGVsLlxuICAgKiAtIEFtYXpvbiBUaXRhbiBUZXh0IEVtYmVkZGluZ3M6IDgxOTJcbiAgICogLSBDb2hlcmUgRW1iZWQgbW9kZWxzOiA1MTJcbiAgKi9cbiAgcHVibGljIHN0YXRpYyBzZW1hbnRpYyhwcm9wczogQ2ZuRGF0YVNvdXJjZS5TZW1hbnRpY0NodW5raW5nQ29uZmlndXJhdGlvblByb3BlcnR5KTogQ2h1bmtpbmdTdHJhdGVneSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgY2h1bmtpbmdTdHJhdGVneTogQ2h1bmtpbmdTdHJhdGVneVR5cGUuU0VNQU5USUMsXG4gICAgICAgIHNlbWFudGljQ2h1bmtpbmdDb25maWd1cmF0aW9uOiBwcm9wcyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgZm9yIGRlZmluaW5nIGEgbm8gY2h1bmtpbmcgc3RyYXRlZ3kuICovXG4gIHByaXZhdGUgc3RhdGljIG5vQ2h1bmtpbmcoKTogQ2h1bmtpbmdTdHJhdGVneSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgY2h1bmtpbmdTdHJhdGVneTogQ2h1bmtpbmdTdHJhdGVneVR5cGUuTk9ORSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUHJvcGVydGllc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqIFRoZSBDbG91ZEZvcm1hdGlvbiBwcm9wZXJ0eSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbmZpZ3VyYXRpb24gKi9cbiAgcHVibGljIGFic3RyYWN0IGNvbmZpZ3VyYXRpb246IENmbkRhdGFTb3VyY2UuQ2h1bmtpbmdDb25maWd1cmF0aW9uUHJvcGVydHk7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHsgfVxufSJdfQ==